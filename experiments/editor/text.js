/**
 * WordFilter is the abstract base class (or interface) for the
 * things that will be used to mark/match words in some way.
 */
function WordFilter(){
}
WordFilter.prototype.add = function(word){
	// adds the words to the list
	// returns nothing
}
WordFilter.prototype.test = function(word){
	// returns true if the word is in the list
	// returns false if the word is not in the list
}

/**
 * WordFilterBloom uses a bloom filter to test is a word is in the
 * list. Since it is a bloom filter it can tell if a word is
 * *definitely not* in the list. However, it can only tell if a word
 * is probably in the list. This means it may think some words are in
 * the list (returns true) when they are not.
 * Takes constant time to make this assessment regardless of the size
 * of the word list O(1).
 * Memory is O(1) because it does not store everyword.
 */
function WordFilterBloom(){
	this._bloomFilter = new BloomFilter(
		32 * 256, // number of bits to allocate.
		4        // number of hash functions.
	);
}
WordFilterBloom.prototype.add = function(word){
	this._bloomFilter.add( word );
}
WordFilterBloom.prototype.test = function(word){
	return this._bloomFilter.test( word );
}

/**
 * WordFilterListSearch stores the words as a list and searches
 * through the list for a word.
 * The more words in the list the longer it takes to search O(n).
 * Under the hood there may be some optimizations which make it
 * run in O(log(n)), by sorting the list.
 * Memory use is O(n) because it stores every word.
 */
function WordFilterListSearch(){
	this._words = [];
}
WordFilterListSearch.prototype.add = function(word){
	this._words.push( word );
}
WordFilterListSearch.prototype.test = function(word){
	return (this._words.indexOf( word ) > -1);
}

/**
 * WordFilterHashMap uses a hashmap (implemented as a javascript
 * object) to store words in the list.
 * May run into issues with words that match built-in js keywords.
 * Speed: O(1)
 * Memory: O(n)
 */
function WordFilterHashMap(){
	this._words = {};
}
WordFilterHashMap.prototype.add = function(word){
	this._words[word] = 0;
}
WordFilterHashMap.prototype.test = function(word){
	return this._words.hasOwnProperty(word);
}

/**
 * Controls conversion from multiline html text (as generated by
 * contentEdible things in a webpage) to plain text.
 */
function NewLineManager(){
}
NewLineManager.prototype.htmlToPlain = function( html ){
	// replace all <br>'s with '\n'
	// then remove ALL the tags
	var result = html;
	result = result.replace(/(<br>)?((<\/p>)|(<\/div>))/gi, '\n' );
	result = result.replace(/<br>/gi, '\n' );
	result = result.replace(/(<([^>]+)>)/gi, "");
	return result;
}
NewLineManager.prototype.plainToHtml = function( text ){
	var result = text;
	// result = result.replace(/\n/gi, '<br>' );
	result = result.replace(/\n/g, '</p><p>' );
	result = '<p>'+result+'</p>';
	result = result.replace(/<p><\/p>/g, '<p><br/></p>'); 
	return result;
}

/**
 * Words and non-words are used so we can "normalize" whitespace for
 * word comparision with grammars and other rules. And then we can
 * reconstruct the original text with the original whitespace and
 * punctuation.
 */
function Word( raw ){
	this.raw = raw;
	this.annotations = [];
}
Word.prototype.isWord = function(){
	return true;
}
Word.prototype.isNonWord = function(){
	return false;
}
Word.prototype.addAnnotation = function( annotation ){
	this.annotations.push( annotation );
}
Word.prototype.asString = function(){
	return this.raw;
}
function NonWord( raw ){
	this.raw = raw;
}
NonWord.prototype.isWord = function(){
	return false;
}
NonWord.prototype.isNonWord = function(){
	return true;
}
NonWord.prototype.addAnnotation = function( annotation ){
	// should not do anything, non-words do not have annotations
	return;
}

/**
 * The TextWordAnalyzer splits raw_text into Words and NonWords.
 * Words can be "tested" against a checker and annotated. After
 * the annotation is completed - html can be generated which
 * contains the annotations.
 * Note: this has too many responsibilities and should be refactored
 * in the future if anything is added to it.
 */
function TextWordAnalyzer( raw_text ){
	this._raw = raw_text;
	this._parts = [];
	this._wordIndexes = [];
	this._wordCounts = {};
	this._divideIntoWords();
	this._computeProperties();	
}
TextWordAnalyzer.prototype._divideIntoWords = function(){
	var _rawParts = this._raw.split(/\b/);
	for( var i=0, l=_rawParts.length; i<l; i+=1 ){
		var part = _rawParts[i];
		// only check the first character -- assume the rest of the
		// word is in the same "class"
		if( this._isSplitter( part[0] ) ){
			this._parts.push( new NonWord( part ) );
		}else{
			this._parts.push( new Word( part ) );
		}
	}
};
TextWordAnalyzer.prototype._computeProperties = function(){
	for( var i=0,l=this._parts.length; i<l; i+=1 ){
		var part = this._parts[i];
		if( part.isWord() ){
			this._wordIndexes.push( i );
			if( ! this._wordCounts.hasOwnProperty(part.raw) ){
				this._wordCounts[ part.raw ] = 0;
			}
			this._wordCounts[ part.raw ] += 1;
		}
	}
};
TextWordAnalyzer.prototype.getWordCount = function(){
	return this._wordIndexes.length;
};
TextWordAnalyzer.prototype._isSplitter = function( character ){
	var nonAlphas = ' .,-!"\';:#$%&~()\t*+/<=>?@\^_`{|}[]';
	return nonAlphas.indexOf( character ) > -1;
};
TextWordAnalyzer.prototype._getWord = function( index ){
	return this._parts[ this._wordIndexes[index] ];
};
TextWordAnalyzer.prototype.indexOf = function(textWordAnalyzer){
	var that = textWordAnalyzer;
	// We cannot contain a larger substring than our length
	var thatCount = that.getWordCount();
	var thisCount = this.getWordCount();
	if( thatCount > thisCount ){
		return -1;
	}
	for( var a=0; a<thisCount; a+=1 ){
		for( var b=0; b<thatCount; b+=1 ){
			if( this._getWord(a+b).raw != that._getWord(b).raw ){
				break;
			}
		}
		if( b == thatCount ){
			return a;
		}
	}
	return -1;
};
TextWordAnalyzer.prototype.markFailures = function( filter, annotation ){
	for( var a=0; a<this.getWordCount(); a+=1 ){
		var word = this._getWord(a);
		if( ! filter.test( word.raw.toLowerCase() ) ){
			word.addAnnotation(annotation);
		}
	}
}
TextWordAnalyzer.prototype.markMatches = function( filter, annotation ){
	for( var a=0; a<this.getWordCount(); a+=1 ){
		var word = this._getWord(a);
		if( filter.test( word.raw.toLowerCase() ) ){
			word.addAnnotation(annotation);
		}
	}
}
TextWordAnalyzer.prototype.generateTippy = function(){
	// Todo: make a separate class OutputGenerator?
	var output = '';
	for( var i=0, l=this._parts.length; i<l; i+=1 ){
		var part = this._parts[i];
		if( part.isWord() && part.annotations.length > 0 ){
			output += '<span class="has-tooltip" data-tippy-content="'
			output += part.annotations.join(', ');
			output += '">';
			output += part.raw;
			output += '</span>';
		}else{
			output += part.raw;
		}
	}
	return output;
}

/**
 * The Text class can be used to annotate sections of text
 * at arbitrary positions and generate another representation
 * of the text with the annotations. It does not understand
 * anything about words or word boundaries.
 */
function Text(raw_text){
	this._raw = raw_text;
	this._selections = [];
	this.annotations = [];
}
Text.prototype.has_valid_selection = function(){
	return this._selections.length > 0;
};
Text.prototype.select_by_index = function(start,end){
	this._selections = [new Range(start,end)];
};
Text.prototype.select_by_search_string = function(str){
	var start = this._raw.indexOf(str);
	if( start != -1 ){
		this._selections = [
			new Range(start,start+str.length)
		];
	}
};
Text.prototype.select_by_search_regexp = function(regexp){
	//var match = this._raw.match(regexp);
	var match = regexp.exec( this._raw );
	this._selections = [];
	while( match !== null ){
		var start = match.index;
		var end = start + match[0].length;
		this._selections.push( new Range(start,end) );
		match = regexp.exec( this._raw );
	}
};
Text.prototype.annotate_selection = function(meta_data){
	if( ! this.has_valid_selection() ){
		throw new Error('Invalid selection');
	}
	for( var i=0, l=this._selections.length; i<l; i+=1 ){
		var selection = this._selections[i];
		this.annotations.push( new Annotation(
			selection.copy(),
			this._raw.slice(selection.start,selection.end),
			meta_data
		) );
	}
};
Text.prototype.insert_at_selection = function(value){
	if( ! this.has_valid_selection() ){
		throw new Error('Invalid selection');
	}
	for( var i=0, l=this._selections.length; i<l; i+=1 ){
		var selection = this._selections[i];
		if( selection.start !== selection.end ){
			throw new Error('Invalid selection');
		}
		this._insert_at_position( selection.start, value );
	}
};
Text.prototype._insert_at_position = function(index,value){
	for( var i=0, l=this.annotations.length; i<l; i+=1 ){
		var annotation = this.annotations[i];
		if( annotation.range.start >= index ){
			annotation.range.start += value.length;
		}
		if( annotation.range.end >= index ){
			annotation.range.end += value.length;
		}
	}
	this._raw = this._raw.slice(0,index) + value + this._raw.slice(index);
};
Text.prototype.annotations_to_markdown = function(){
	// TODO: copy the entire Text object first and work on the copy
	// because this destroys the original
	for( var i=0, l=this.annotations.length; i<l; i+=1 ){
		var annotation = this.annotations[i];
		this.select_by_index( annotation.range.start, annotation.range.start );
		this.insert_at_selection( '(' );
		this.select_by_index( annotation.range.end, annotation.range.end );
		this.insert_at_selection( ')['+annotation.meta+']' );
	}
	// TODO: delete all annotations?
};
Text.prototype.markup_annotations = function( process_annotation ){
	// TODO: copy the entire Text object first and work on the copy
	// because this destroys the original
	for( var i=0, l=this.annotations.length; i<l; i+=1 ){
		var annotation = this.annotations[i];
		var new_markup = process_annotation( annotation );
		this.select_by_index( annotation.range.start, annotation.range.start );
		this.insert_at_selection( new_markup.start );
		this.select_by_index( annotation.range.end, annotation.range.end );
		this.insert_at_selection( new_markup.end );
	}
	// TODO: delete all annotations?
};

function Range(start,end){
	this.start = start;
	this.end = end;
}
Range.prototype.move = function( delta ){
	this.start += delta;
	this.end += delta;
};
Range.prototype.copy = function( ){
	return new Range(this.start,this.end);
};

function Annotation( range, value, meta ){
	this.range = range;
	this.value = value;
	this.meta = meta;
}
Annotation.prototype.set_range = function(range){
	this.range = range;
}
Annotation.prototype.set_value = function(value){
	this.value = value;
}
Annotation.prototype.set_meta = function(meta){
	this.meta = meta;
}
Annotation.prototype.copy = function(){
	return new Annotation(
		this.range.copy(),
		this.value,
		this.meta
	);
}

var text = new Text('This is some text');
//text.select_by_index( 4, 7 );
//text.annotate_selection('Wut?');

text.select_by_search_string( 'some' );
text.annotate_selection('We found some');

text.select_by_search_regexp( /is/g );
text.annotate_selection('We found is');

text.select_by_index( 0, 0 );
text.insert_at_selection( 'Nothing! ' );

text.annotations_to_markdown();

console.info( text );
